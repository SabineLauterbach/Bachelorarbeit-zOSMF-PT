\chapter{Grundlagen}\label{ch:grundlagen}
Um den Unterschied zwischen modernen cloud native Entwicklungsprozessen und dem Mainframe Entwicklungsprozess darstellen zu können, werden zunächst Begriffe aus dem cloud-native-Umfeld erläutert.
Dabei wird auch auf den dadurch ermöglichten Entwicklungsprozess, dessen Vorteile und Begrifflichkeiten eingegangen.
Anschließend werden für die Beantwortung der Forschungsfragen relevanten Begriffe des Mainframe-Umfelds beleuchtet.

\section{cloud-native bei der DATEV e.G.}
Eine cloud-native Anwendung ist eine speziell für das Cloud-Computing\footnote{Glossar \ref{Glossar}} konzipierte und entwickelte Anwendung.
Oft werden damit Online-Anwendungen und mobile "Apps" entwickelt, für die häufig und hoch frequent neue Features bereitgestellt werden sollen. 
Für solche Anwendung ist das Architekturpattern der sogenannten \glqq Microservices\grqq, weit verbreitet.
Diese einzelnen entkoppelten Services sind z.B. in Containern paketiert. 
Bekannt geworden ist hier der Ansatz von Docker. (Kommentar: würde ich erwähnen, da z/OSpt explizit ein "docker like" vorgehen unterstützt. also auch enie Quelle angeben)
Diese Container und somit die Anwendung können auf verschiedenen Cloud-Umgebungen, auch von unterschiedlichen Anbietern,  ausgeführt werden.
Dort können bereitstehende Services für Datenhaltung, Security, Messaging usw. genutzt werden. 
Dadurch ist eine schnelle Reaktion auf Markt- und Kundenanforderungen möglich.
Außerdem besteht dadurch eine geringere Herstellerabhängigkeit. (Kommentar: die beiden Sätze sind grundsätzlich richtig, aber ich würde sie etwas erläutern, z.B: ist man mit MongoDB und COnfluent Kafka nicht per se herstellerunabhängig. aber man hat mehr optionenh).\cite{cloudnative.23.2.2020}\\
Eine moderne cloud-native Anwendung innerhalb der DATEV e.G. machen folgende Dinge aus:
\begin{itemize}
\item \glqq Cloud Foundry\grqq
\item CI/CD-Pipeline
\end{itemize}

\subsection{\glqq Cloud Foundry\grqq}
Bei Cloud Foundry handelt es sich um eine quelloffene Platform-as-a-Service, kurz PaaS.
Platform-as-a-Service, beschreibt neben Insfrastructure-as-a-Service, kurz IaaS und Software-as-a-Service, kurz SaaS, einen Grad an Auslagerung von IT-Systemen in die Cloud.
IIm Vergleich zu SaaS, bei der ganze Anwendungen in einer Cloud zur Verfügung stehen, und IaaS, bei der die automatisierte Bereitstellung von Infrastrukturkomponenten wie Netzwerk, SPeicher usw. im Fokus steht, stellt eine PaaS-Lösung eine Plattform, die sich neben der Infrastruktur auch um das Betriebssystem, die Middleware und die Laufzeitumgebung kümmert, bereit. (Kommentar: Quelle z.B: https://www.ibm.com/de-de/cloud/learn/iaas-paas-saas)
Für die Verwaltung von Ressourcen bietet Cloud Foundry eine Weboberfläche, den sogenannten \glqq Marketplace\grqq, an.
In diesem können mit wenigen Mausklicks Schnittstellen zu Services wie Datenbankmanagementsysteme, Messaging- oder Monitorlösungen zur Anwendung hinzugefügt werden.
Diese Schnittstellen, auch \glqq Self-Service\grqq{} oder \glqq Service-Broker\grqq{} genannt, können mittels einer von Cloud Foundry zur Verfügung gestellten API selbst entwickelt werden.
Ein Vorteil ist, dass sich Cloud Foundry um das Staging der Anwendungen kümmert.
D.h. eine Anwendung kann mit den benötigten Komponenten sicher von einer Entwicklungs- in eine QS- bzw. Produktiv-Stage verschoben werden. 
Um eine Anwendung in eine solche Stage bereitzustellen, bietet Cloud Foundry ein Kommandozeileninterface an.
Neben der Bereitstellung können mit diesem Interface beispielsweise Anwendungen auch horizontal skaliert werden.
Um die Breitstellung über mehrere Stages hinweg zu automatisieren komm bei der DATEV e.G. eine auf Jenkins basierende CI/CD-Pipeline zum Einsatz.
\cite{foundry.23.2.2020}

\subsection{\glqq CI/CD-Pipeline\grqq}\label{sec:cicd}
CI/CD steht für \glqq Continous Integration und Continous Delivery\grqq{} in manchen Fällen auch für \glqq Continous Integration, Continous Delivery und Continous Deployment\grqq{}.
Die einzelnen Begriffe werden im Folgenden erläutert, als Überblick dient Abbildung \ref{fig:cicd}

(KOmmentar: ich würde noch etwas zur CI/CD Pipeline schreiben udn auf DevOPs usw. eingehen. VOrschlag (bitte in eigenen Worten wiedergeben...) 
 CI/CD Pipeline automatisiert den Entwicklungsprozess. 
Build, Test, Quality Gates (z.B: Codequalitäts-CHecks) und 
Deployment.  
Automatisierung durch Jenkins 
GIT als Sourceverwaltung.  
Ziel bei DATEV eG i"Product-Teams" 
schnell, ohne manuelle Schritte und Koordinationsbedarf (autonom) 
"Operations"-Teams, kontinuierlich Wert für Kunden liefern können. 
DevOps Ansatz. 
Amazon, ein wichtiger Cloud-Anbieter zitieren
https://aws.amazon.com/de/devops/what-is-devops/ zu DevOps folgendes: 
"Dabei kommen Praktiken zur Automatisierung von traditionell manuellen, zeitaufwendigen Prozessen zum Einsatz. Der verwendete Technologie-Stack und die genutzten Tools ermöglichen eine schnelle und zuverlässige Ausführung und Weiterentwicklung von Anwendungen. Diese Tools ermöglichen Engineers auch, in Eigenregie Aufgaben zu erledigen (wie beispielsweise die Bereitstellung von Code oder Infrastruktur), für die sie üblicherweise auf die Unterstützung anderer Teams angewiesen waren. Das Ergebnis ist auch hier eine erhöhte Geschwindigkeit."

vlt. noch was zu Architektur, Cloud Native Anwendungen
Microservices,  12-factor-Apps.
Autonomie von Anwendungen zur Entwicklungs-und Betriebszeit eitgehend unabhängig von anderen Services entwickelt und produktiv ...



HIER BILD VON CICD ÜBERBLICK EINFÜGEN!!!
\paragraph{\glqq Continous Integration\grqq}~\\
\cite{Laster.2017}

\paragraph{\glqq Continous Delivery\grqq}~\\
\cite{Laster.2017}

\paragraph{\glqq Continous Deployment\grqq}~\\
\cite{Laster.2017}



\section{Mainframe / Großrechner}\label{sec:mainframe}
Im modernen Sprachgebrauch kann ein Großrechner oder auch Mainframe als größte zur Verfügung stehende Serverart betrachtet werden.
Er wird von Unternehmen verwendet, um  kommerzielle Datenbanken, Transaktionsserver und Anwendungen, die einen hohen Grad an Sicherheit und Verfügbarkeit benötigen, zu hosten.
Im Gegensatz zu verteilten Serversystemen, bei denen die Funktionalitäten auf einzelne Server, wie zum Beispiel einen E-Mail-Server, einen Datenbank-Server, einen Web-Server usw. aufgeteilt sind, handelt es sich bei einem Mainframe um ein zentralisiertes System.
Die einzelnen Funktionalitäten werden von sogenannte \glqq Subsysteme\grqq, auch \glqq Middleware\grqq{} genannt, zur Verfügung gestellt.
Darunter zählen unter anderem Datenbanksysteme und Anwendungsserver.

(Kommentar: hier könnte man die Abgrenzung zu Cloud native machen....)
im Gegensatz zu cloud native sind z/OS Anwendungen häufig monolithisch
.... shared subsystems....
CI/CD pipeline nicht vorhanden aber im Aufbau
du kümmerst dich v.a. um den self service aspekt von PaaS...

\cite{Ebbers.2011}

\section{Mainframe Anwendungen bei DATEV e.G.}\label{sec:zosanw}
Das Betriebssystem des IBM Mainframes ist z/OS.
Darauf aufbauend benötigen klassische z/OS Anwendungen bestimmte Middleware.
Bei der DATEV e.G. handelt es sich unter anderem um folgende Middlewarekomponenten:

\begin{itemize}
\item Laufzeitumgebung: CICS oder Batch
\item Datenhaltung: VSAM oder Db2
\item Message Queuing: IBM MQ
\end{itemize}

Diese Subsysteme stehen in jeder Stage zur Verfügung.
Eine Stage beschreibt eine isolierte Systemumgebung mit eigenen Subsystemen und Ressourcenverwaltung.
Die DATEV e.G. unterscheidet am Mainframe vier Stages:
\begin{samepage}
\begin{itemize}
\item Testplex:\\
Labor für Änderungen am System, beispielsweise einer neuen Betriebssystemsversion
\item Entwicklung:\\
Implementierung neuer Features und Durchführung kleiner Tests
\item Qualitätssicherung:\\
Durchführung von Integrationstests
\item Produktion:\\
Software, die für den Kunden bereitsteht
\end{itemize}
\end{samepage}

\section{Subsysteme / Middleware}
Für die Beantwortung der Forschungsfragen liegt der Fokus auf dem Erstellen (\glqq Provisionieren \grqq) einer anwendungsspezifischen Laufzeitumgebung mit einer Datenhaltung und Message Queuing innerhalb des Testplexes und der Entwicklung.
Als Laufzeitumgebung wird \glqq CICS\grqq, als Datenhaltung \glqq Db2\grqq{} und für das Message Queuing \glqq IBM MQ\grqq{} verwendet.
Wie in Abbildung \ref{fig:archüber} dargestellt ist, existieren mehrere Instanzen pro Subsystem.
Es existiert bei der DATEV e.G. jedoch nur eine geringe Anzahl an Instanzen pro Subsystem.
Diese Instanzen sind langlebig und müssen dahingehend gepflegt und gewartet werden.
Daraus folgt, dass sich, wie in der Problemstellung, Absatz \ref{sec:probstell}, bereits erwähnt, viele Anwendungen die gleichen Test-CICS/Db2/MQ Ressourcen teilen.
Diese einzelnen Subsysteme werden im Folgenden erläutert, hierzu dient Abbildung \ref{fig:archüber} als Überblick.

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{figures/architektur.pdf}
\caption{Architekturübersicht über die Subsysteme einer Stage bei DATEV eG}
\label{fig:archüber}
\end{figure}

\subsection{Customer Information Control System}\label{cics}
Das Customer Information Control System, kurz CICS, ist ein Applikationsserver für einen IBM-Großrechner mit Betriebssystem z/OS und damit eine IBM Middleware.
Ein Applikationsserver stellt eine Umgebung zur Verfügung, in der Anwendungen gehostet werden können.
Dabei kümmert sich dieser unter anderem um Transaktionalität, Webkommunikation und Sicherheit.
Hierfür stellen Applikationsserver eine API zur Verfügung.
CICS hat einen Vorteil gegenüber anderen Anwendungsservern, es unterstützt verschiedene Programmiersprachen.
CICS ist ein Multi-Language Application Server und unterstützt z.B. COBOL, Assembler, Java und PLI.
So können Programme innerhalb einer Anwendung in der für ihren Use-Case am besten geeigneten Sprache implementiert werden.
\cite{Rayns.2011}

Das CICS Subsystem einer Stage umfasst mehrere CICS Instanzen.

\subsubsection{CICS Instanz} 
Unter einer CICS Instanz ist ein einzelner Bereich, der auf dem z/OS Kernel aufsetzt, zu verstehen.
Dieser Bereich ist mittels einer eindeutigen CICS ApplicationID gekennzeichnet und kann darüber explizit angesprochen werden.
Eine CICS Instanz verwaltet mehrere CICS Transaktionen.

Wenn in dieser Arbeit von dem CICS gesprochen wird, ist die CICS-Instanz damit gemeint.

\subsubsection{CICS Transaktion}\label{subsec:trans}
Ein Businessablauf wird im CICS in einer Transaktion gekapselt.
Eine Transaktion kann mehrere Programme unterschiedlicher Programmiersprachen umfassen und wird über eine eindeutige \glqq TransaktionsID\grqq{} identifiziert..

Über die TransaktionsID wird der Ablauf gestartet.
Dies kann sowohl per Webanfrage oder per Messaging Queue als auch aus einem anderen Programm heraus oder manuell geschehen.
In der Transaktion werden alle Änderungen, die Programme an Ressourcen, wie zum Beispiel einer Datenbank oder Dateien tätigen, protokolliert.
So wird im Falle eines Fehlers die Möglichkeit eines Rollbacks sichergestellt.
 \cite{Rayns.2011}

\subsection{Db2}\label{sssec:db2}
Db2 ist ein relationales Datenbanksystem, welches unter anderem als Subsystem eines z/OS Betriebssystems läuft.
Einer Stage können mehrere Datenbanksysteme, auch Instanzen genannt, zugeordnet werden.
In einer Instanz befinden sich die Datenbanken und Tabellen.

\subsection{IBM MQ}\label{sec:mq}
IBM MQ ist eine Messaging-Lösung der IBM.
Diese ermöglicht den asynchronen Datenaustausch zwischen Anwendungen mittels sogenannter Queues.
Alle IBM MQ Begrifflichkeiten, die in dieser Arbeit verwendet werden, werden im Folgenden erläutert.
\cite{Aranha.2013}

Das IBM MQ Subsystem einer Stage setzt sich aus einem oder mehreren Queue Managern zusammen.
Ein Queue Manager kann daher als IBM MQ Instanz gesehen werden.

\subsubsection{Queue Manager}
Bei einem Queue Manager handelt es sich um die zentrale Ressource eines IBM MQ Systems.
Er verwaltet  alle anderen IBM MQ Ressourcen.
Dazu gehören unter anderem die Speichersteuerung der Daten und die Wiederherstellung dieser im Falle eines Fehlers.
Desweiteren koordiniert er den Zugriff aller Anwendungen auf die Nachrichten in den von ihm verwalteten Queues.
Um hierbei die Konsistenz sicherzustellen, sorgt er für Locking und die notwendige Isolation der Queues.
\cite{Aranha.2013}

\subsubsection{Queues}
In Queues werden die Nachrichten, die von Programmen gesendet und gelesen werden gespeichert.
Es gibt verschiedene Arten von Queues, die im Kontext dieser Arbeit relevanten Queues sind folgende:

\paragraph{Die Local Queue.}~\\
Dabei handelt es sich um die einzige Queue Art, bei der die Nachrichten physikalisch gespeichert werden.
Die anderen Queue Arten nutzen als Basis immer eine Local Queue.

\paragraph{Initiation Queue}~\\
Die sogenannte \glqq Initiation Queue\grqq{} ist eine spezielle Art der Local Queue.
Diese dient dem Queue Manager dazu, unter bestimmten Bedingungen eine Trigger-Nachricht darauf zu schreiben.
Daher kann eine andere Local Queue so definiert sein, dass sobald eine Nachricht auf sie geschrieben wird eine solche Trigger-Nachricht erzeugt wird.
Dies ermöglicht, dass Anwendungen nur starten, wenn wirklich Daten zum Verarbeiten vorhanden sind.
\cite{Aranha.2013}

\subsubsection{Process}
Für das Auslösen von Anwendungen wird nicht nur die Initiation Queue benötigt, sondern auch sogenannte \glqq Processes\grqq.
So muss der Local Queue, die den Start einer Anwendung auslösen soll, bei der Definition nicht nur die Initiation Queue bekannt gemacht werden, sondern auch ein Process.
Ein Process legt den \glqq Type\grqq{} und den Namen der zu startenden Anwendung fest.
Als \glqq Type\grqq{} können beispielhaft CICS oder auch WINDOWSNT für Windows unterstütze Plattformen genannt werden.
Ist der \glqq Type\grqq{} CICS,  muss der Name der Transaktion angegeben werden, für Windows Plattformen der Dateipfad der auszuführenden exe.
\cite{Aranha.2013}

\section{\glqq IBM Cloud Provisioning and Management for z/OS\grqq}
Die Verwaltung von Subsystemen von z/OS ist mit vielen manuellen Schritten verbunden.\footnote{Analyse des aktuellen Bereitstellungsprozesses, siehe in Absatz \ref{sec:aktbereit}}
Betreut werden die einzelnen Subsysteme über alle Stages hinweg von eigens dafür zuständigen Administratorenteams.
Die \glqq CICS Administration\grqq{} kümmert sich um alles rund um das CICS Subsystem.
Die \glqq Db2 Administration\grqq{} stellt Datenbanken und Tabellen auf Anfrage der Entwickler bereit.
Die \glqq IBM MQ Administration\grqq{} verwaltet die IBM MQ Ressourcen.
Um diese Aufgaben zu bewältigen, sind aktuell in erster Linie proprietäre Tools im Einsatz, die nicht der Erwartungshaltung an moderne Administrationstools entsprechen. (Kommentar: hier würde ich ein Bild einer "alten" Admin-Oberfläche als Beispiel zeigen, irgendeinen CICS-Dialog von den Admins, möglichst ISPF oder BMS )

Für die Automation dieser Prozesse bietet die IBM das \glqq IBM Cloud Provisioning and Management for z/OS\grqq{} an.
Dabei handelt es ich um ein bei der Installation von \glqq z/OS Management Facility\grqq{}\footnote{Siehe Absatz \ref{sssec:zosmf}}, kurz z/OSMF, mitgeliefertes Tool. (Kommentar: z/OSMF ist Teil des Betriebssystems)
z/OSMF ist wiederum Teil der Standardauslieferung des Betriebssystems z/OS.
Es soll z/OS-Administration über moderne Oberfläschen und APIs  ermöglichen.
z/OSMF (und damit auch „IBM Cloud Provisioning and Management for z/OS“) ist bei DATEV verfügbar, wird aber noch nicht flächendeckend eingesetzt, da die Administratoren den herkömmlichen Tools vertrauen und eine Umstellung immer auch mit Lernaufwand und Einarbeitung verbunden ist. (Kommentar: wieso beide: meinst Du das „IBM Cloud Provisioning and Management for z/OS“ und z/OSMF? Eigentlich ist das 1 Tool, ersteres ist Teil von zweiterem) 
Sie sind auch außerhalb der DATEV e.G. kaum verbreitet. (Kommentar: über z/OSMF an sich bin ich mir nicht sicher, wenn dann könnte man höchstens sagen, das „IBM Cloud Provisioning and Management for z/OS“ ist noch nicht weit verbreitet). 
Auch aus Sicht der IBM besteht Interesse an Erfahrungsberichten zur Nutzung von \glqq IBM Cloud Provisioning and Management for z/OS\grqq.
So wurde im Rahmen der neunzehnten \glqq AMC\grqq{}\footnote{Academic Mainframe Consortium e.V.} Tagung im IBM Client Center Böblingen am 16.01.2020 um ca. 14:30  bei einem ca. 30 minütigen Vortrag ein Arbeitsstand dieser Arbeit vorgestellt.
Die Agenda der Veranstaltung ist im Anhang \ref{app:AMC} zu finden.
Der AMC e.V. ist ein Förderverein für die akademische Ausbildung auf dem Mainframe.\footnote{\cite{Amc.23.2.2020}}
Neben Vertretern der IBM nahmen an der Tagung Vertreter von Hochschulen und verschiedenen Unternehmen teil.
Der Vortrag \glqq kam ja sehr gut an und hat auch später noch zu Gesprächen geführt\grqq\footnote{AMC Vorstand Ernst Lugert, 20.1.2020}.
(Kommentar: ist das Zitat nur das "kam ja sehr gut an" oder gehört auch der Teil "hat auch später noch zu Gesprächen geführt"? Der zweite Teil scheint nicht aus einem Gespräch zu stammen. d.h. hier bitte nochmal drauf schauen".)
In den anschließenden Gesprächen wurde deutlich, dass sich neben der DATEV e.G. und der IBM auch andere Firmen für die automatisierte Provisionierung von z/OS Middleware mit \glqq IBM Cloud Provisioning and Management for z/OS\grqq{} interessieren, aber noch kaum Erfahrung in dem Umfeld besteht.

Bei \glqq IBM Cloud Provisioning and Management for z/OS\grqq{} stehen die sogenannten \glqq Templates\grqq{} im Mittelpunkt.
Dabei handelt es sich um eine Art Script. (Kommentar: kann man das so sagen?)
Mit Hilfe eines Templates können Instanzen erzeugt werden.
Diese Instanz kann eine oder mehrere verschiedene Subsystem-Instanzen enthalten.
Dabei steht sowohl eine schnelle Provisionierung als auch Deprovisionierung von Instanzen durch den Entwickler im Vordergrund.
Mittels Templates läuft beides automatisiert, verlässlich und ohne manuelle Abstimmungen ab.
Die Bereitstellung einer Instanz ist wiederholbar, so kann die Instanz z.B. im Fehlerfall sicher neugestartet werden und muss nicht langlebig gepflegt werden.
\\ Ein solches Template besteht aus drei Dateien:

\paragraph{\glqq Aktiondefinitionfile\grqq} ~\\
Hier werden die Aktionen, die ein Anwender mit einer Instanz eines Templates durchführen kann, festgelegt.
Einer Aktion wird ein sogenannter \glqq Workflow\grqq{} zugewiesen.

Ein Workflow ist über eine XML Datei, die sogenannte \glqq Workflowdefinitionfile\grqq, definiert.
Diese lässt sich grob in zwei Teile untergliedern:
\begin{itemize}
\item Variablendefinition
\item Steps
\end{itemize}
In der Variablendefinition werden, wie der Name schon sagt, alle Variablen, die für diesen Workflow notwendig sind definiert.

Ein Step beschreibt einen Teilablauf eines Workflows.
Ein Workflow kann aus mehreren Steps bestehen.
Die Steps werden in Definitionsreihenfolge ausgeführt.
Allerdings können Bedingungen für die Durchführung eines Steps definiert werden.
So ist es beispielsweise möglich, einen Step nur durchzuführen, wenn eine bestimmte Variable einen bestimmten Wert besitzt.
Innerhalb eines Steps können sowohl interne und externe Scripte als auch JCLs und somit z/OS Programme ausgeführt werden.
Darüber hinaus besteht die Möglichkeit REST-Calls auszuführen.
Durch ein XML Schema wird sichergestellt, dass die Workflowdefinitionfile keine syntaktischen Fehler beinhaltet.
Sowohl die Variablendefinition als auch die Steps können in externe XML Dateien ausgelagert werden.
Dadurch können Variablen an einer Stelle im Template definiert und in alle Workflowdefinitionfiles aufgenommen werden.
\cite{Rotthove.2018}

Neben den Workflowdefinitionfiles muss in einer Aktion auch der Pfad der sogenannte \glqq Variableinputfile\grqq{} angegeben sein.

\paragraph{\glqq Variableinputfile\grqq}\label{par:variable} ~\\
In dieser Datei werden den in der Workflowdefinitionfile definierten Variablen Werte zugewiesen.
Somit kann das Template für spezifische Anforderungen, z.B. einer speziellen Anwendung,  konfiguriert werden.

\paragraph{\glqq Manifest-File\grqq} ~\\
Hier wird dem Template mitgeteilt, an welchem Speicherort sich die oben genannten Dateien befinden.
Da ein Template immer provisioniert werden kann, wird hier auch der Speicherort des Provisionierungsworkflows angegeben.
Zusätzlich kann noch eine Beschreibung des Templates hinzugefügt werden.
\cite{IBM.2019}

Für die Provisionierung eines Templates müssen diesem eine sogenannte \glqq Domain\grqq{} und ein \glqq Tenant\grqq{} zugewiesen werden.
Unter einer \glqq Domain\grqq{} ist ein System zu verstehen, das Systemressourcen in Ressourcenpools gliedert.
\glqq Tenants\grqq{} sind die dazugehörigen Rechtegruppen, die dem Anwender den Zugriff auf und die Nutzung von zugeordneten Templates ermöglicht.
\cite{Rotthove.2018}

Dies umfasst zwei Lösungen, (Kommentar: die Überleitung mit "DIes umfasst" bekomme ich gerade nicht hin... auf was beziehst Du Dich mit "Dies"?) \glqq z/OS Provisioning Toolkit\grqq\footnote{siehe Absatz \ref{sssec:zospt}} und \glqq z/OS Management Facility\grqq\footnote{siehe Absatz \ref{sssec:zosmf}}.

\subsection{z/OS Provisioning Toolkit}\label{sssec:zospt}


Das z/OS Provisioning Toolkit, kurz z/OSPT bietet für das Provisionieren von Laufzeitumgebungen ein Kommandozeileninterface für die Bereitstellung und das Verwalten von Templates bzw. "Images" sowie das Starten von Instanzen an. 
Dabei orientiert sich z/OSPT an der Docker Commandline und spricht von Containern (auch wenn es in z/OS diese nicht gibt) und Images.

https://docs.docker.com/engine/reference/commandline/docker/) (Kommentar: siehe auch....https://searchitoperations.techtarget.com/definition/Docker-image 
A Docker image includes the elements needed to run an application as a container -- such as code, config files, environment variables, libraries and run time. If the image is deployed to a Docker environment it can then be executed as a Docker container. The docker run command will create a container from a given image.)
(Kommentar: wird bei z/OSPT tatsächlich von Templates gesprochen, oder sind das in dem Zusammenhang immer Images?)
In Abbildung \ref{fig:zospt_help} werden die möglichen Kommandozeilenbefehle mittels des Befehls \glqq zospt -h\grqq{} in einem Kommandofenster angezeigt. 
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{figures/zospt_help_putty.png}
	\caption{z/OSPT mögliche Kommandozeilenbefehle}
	\label{fig:zospt_help}
\end{figure}

Mit z/OSPT werden zwei weitere Begriffe eingeführt.\\
\paragraph{\glqq Images\grqq}~\\
Dabei handelt es sich grundsätzlich um ein Template, jedoch kann dieses Template über eine weitere Inputdatei configuriert werden.
Dadurch kann ein Template mit spezifischen Änderungen provisioniert werden, ohne dass ein neues Template erzeugt werden muss.
Dies erhöht die Flexibilität der Templates. 

\paragraph{\glqq Container\grqq}~\\
Dabei handelt es sich um eine Template-Instanz und ist damit die lauffähige Variante eines Templates.\footnote{Beschreibung in Absatz \ref{sssec:instance}}.
(Kommentar: vlt. kannst Du hier erwähnen: mit RUN startet man ein Image und erzeugt einen Container, mit start stop managed man den Life Cycle, -images zeigt die verfügbaren Images an usw. 
\cite{IBM.2019b}

\subsection{z/OS Management Facility}\label{sssec:zosmf}
Der Funktionsumfang von z/OS Management Facility, kurz z/OSMF, umfasst Systemmanagementfunktionen
in einer browserbasierenden Benutzeroberfläche, dargestellt in Abbildung \ref{fig:zosmf_welcome}.
Zu diesen Funktionen zählt auch die Verwaltung von Workflows und Templates.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{figures/zosmf.png}
\caption{z/OSMF Willkomens Ansicht}
\label{fig:zosmf_welcome}
\end{figure}

Die linke Seite der Abbildung \ref{fig:zosmf_welcome} zeigt den Umfang der z/OSMF  Funktionen.
Für diese Arbeit besitzt nur der Menüpunkt \glqq Cloud Provisioning\grqq{} Relevanz .
Unter diesem Punkt sind die Funktionalitäten für die automatisierte Bereitstellung von Templates zu finden, und der Begriff "z/OSMF" wird im folgenden synonym für diese Lösung verwendet
\cite{Rotthove.2018}

Unter dem Punkt \glqq Resource Management\grqq{} werden die \glqq Domains\grqq{} und \glqq Tenants\grqq{} verwaltet.
Zur Verwaltung der Templates und Template-Instanzen kommen die \glqq Software Services\grqq{} zum Einsatz.
Dort können neue Templates über die Manifest-Files hinzugefügt werden.
Es folgt, wie oben beschrieben, die Zuweisung einer \glqq Domain\grqq{} und eines \glqq Tenants\grqq{}.
Anschließend kann das Template, falls es keine Fehler beinhaltet, veröffentlicht werden.
Es ist zu empfehlen vorher einen \glqq Test Run\grqq{} durchzuführen.
Dabei wird eine Instance (Kommentar: Instanz oder Instance?) testweise provisioniert.
(Kommentar: Du beschreibst hier das Verwalten von Templates mit z/OSMF viel ausführlicher als mit z/OSPT, hier würde ich beides gleichwertig aufzeigen. Auch wenn danach irgendwann die Entscheidung gefällt wird, nur z/OSMF weiter zu verfolgen, kommt z/OSPT ja noch häufig vor. Bei der Vorstellung sollte sich die spätere Beurteilung noch nicht niederschlagen)
Diese Test-Template-Instanz verhält sich genauso wie eine Instanz, die aus einem veröffentlichten Template erzeugt wurde. 
Somit können  das Template und die in der Aktiondefintionfile definierten Aktionen vor der Veröffentlichung getestet werden.
(Kommentar: ist das das gleiche wie der "RUN" von z/OSPT?)
\cite{Rotthove.2018}
